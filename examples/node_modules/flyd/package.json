{
  "name": "flyd",
  "version": "0.0.3",
  "description": "The less is more, modular, functional reactive programming library",
  "main": "flyd.js",
  "directories": {
    "example": "examples",
    "test": "test"
  },
  "dependencies": {},
  "devDependencies": {
    "bluebird": "^2.9.13",
    "benchmark": "^2.0.0-pre",
    "lodash": "^3.3.1",
    "transducers.js": "^0.2.3"
  },
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/paldepind/flyd.git"
  },
  "keywords": [
    "functional",
    "reactive",
    "modular",
    "library"
  ],
  "author": {
    "name": "Simon Friis Vindum"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/paldepind/flyd/issues"
  },
  "homepage": "https://github.com/paldepind/flyd",
  "testling": {
    "harness": "mocha",
    "files": "test/*.js",
    "browsers": [
      "ie/8..latest",
      "firefox/16..latest",
      "firefox/nightly",
      "chrome/22..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "readme": "# Flyd\nThe less is more, modular, functional reactive programming library in JavaScript.\n\n__Note:__ Flyd is pre-release. It works as advertised – but the API _might_\nchange. Once I've recieved feedback and become certain of the API an actual\nrelease will happen.\n\n[![browser support](https://ci.testling.com/paldepind/flyd.png)\n](https://ci.testling.com/paldepind/flyd)\n\n# Table of contents\n\n* [Introduction](#introduction)\n* [Tutorial](#tutorial)\n* [API](#api)\n\n## Introduction\n\nFunctional reactive programming is a powerful programming paradigm for\nexpressing values that change over time. But existing libraries for JavaScript\nare huge, complex and have a high learning curve.\n\nFlyd is different. It is simple, expressive and powerful. It is fast to learn\nand easy to use. It has a minimal core on top of which new abstractions can be\nbuilt.\n\n## At a glance\n\n* Combineable observable streams with automatic dependency resolution as the\n  building blocks.\n* Extremely simple and lightweight. It's less than 200 SLOC.\n* Supports the transducer protocol. You can for instance transduce streams with\n  ([transducers.js](https://github.com/jlongster/transducers.js).\n* Complies to the [fantasy land](https://github.com/fantasyland/fantasy-land)\n  applicative specification.\n* Elegant support for promises.\n\n[Simple example](http://paldepind.github.io/flyd/examples/sum/).\n\n## Tutorial\n\n### Creating streams\n\nFlyd gives you streams as the building block for creating reactive dataflows.\nThe function `stream` creates a representation of a value that changes over time.\nA stream is a function and at first sight it works a bit like a getter-setter:\n\n```javascript\n// Create a stream with initial value 5.\nvar number = stream(5);\n// Get the current value of the stream.\nnumber(); // returns 5\n// Update the value of the stream.\nnumber(7); // returns 7\n// The stream now returns the new value.\nnumber(); // returns 7\n```\n\nTop level streams, that is streams without dependencies, should typically\ndepend on the external world, like user input and fetched data.\n\nSince streams are just functions you can easily plug them in whenever a\nfunction is expected.\n\n```javascript\nvar clicks = stream();\ndocument.getElementById('button').addEventListener('click', clicks);\nvar messages = stream();\nwebSocket.onmessage = messages;\n```\n\nClicks events will now flow down the `clicks` stream and WebSockets messages\ndown the `messages` stream.\n\n### Dependent streams\n\nStreams can depend on other streams. Instead of calling `stream` with a value\nas in the above examples we can pass it a function. The function calculates a\nvalue based on other streams. Flyd automatically collects the streams\ndependencies and updates it whenever a dependency changes.\n\n```javascript\n// Create two streams of numbers\nvar x = stream(4);\nvar y = stream(6);\n// Create a stream that depends on the two previous streams\n// and with its value given by the two added together.\nvar sum = stream(function() {\n  return x() + y();\n});\n// `sum` is automatically recalculated whenever the streams it depends on changes.\nx(12);\nsum(); // returns 18\ny(8);\nsum(); // returns 20\n```\n\nNaturally, a stream with dependencies can depend on other streams with dependencies.\n\n```javascript\n// Create two streams of numbers\nvar x = stream(4);\nvar y = stream(6);\nvar squareX = stream(function() {\n  return x() * x();\n});\nvar squareXPlusY(function() {\n  return y() + doubleX();\n});\nsquareXPlysY(); // returns 22\nx(2);\nsquareXPlysY(); // returns 10\n```\n\nThe body of a dependent stream is called with two streams: itself and the last\nchanged stream on which it depends.\n\n```javascript\n// Create two streams of numbers\nvar x = stream(1);\nvar y = stream(2);\nvar sum = stream(function(sum, changed) {\n  // The stream can read from itself\n  console.log('Last sum was ' + sum());\n  if (changed) { // On the initial call no stream changed\n    var changedName = (changed === y ? 'y' : 'x');\n    console.log(changedName + ' changed to ' + changed());\n  }\n  return x() + y();\n});\n```\n\n### Using calback APIs for asynchronous operations\n\nInstead of returning a value a stream can update itself by calling itself. This\nis handy when working with callback taking APIs.\n\n```\nvar urls = stream('/something.json');\nvar responses = stream(function(resp) {\n  makeRequest(urls(), resp);\n});\nstream([responses], function() {\n  console.log('Recieved response!');\n  console.log(responses());\n});\n```\n\nThe stream above that logs the responses from the server should only be called\nafter an actual response has been recieved (otherwise `responses()` whould return\n`undefined`). For this purpose you can pass `stream` an array of initial\ndependencies. The stream body not get called before all of the declared\nstreams evaluate to something other than `undefined`.\n\n### Using promises for asynchronous operations\n\nFlyd has inbuilt support for promises. Just like a promise can never be resolved with\na promise, a promise can never flow down a stream. Instead the fulfilled value\nof the promise will be sent down the stream.\n\n```javascript\nvar urls = stream('/something.json');\nvar responses = stream(function() {\n  return requestPromise(urls());\n});\nstream([responses], function() {\n  console.log('Recieved response!');\n  console.log(responses());\n});\n```\n\n### Mapping over a stream\n\nYou've now seen the basic building block of Flyd. Let's see what we can\ndo with them. Lets write a function that takes a stream and a function\nand returns a new stream with the functin applied to every value emitted\nby the stream. In short, a `map` function.\n\n```javascript\nvar mapStream = functin(s, f) {\n  return stream([s], function() {\n    return f(s());\n  });\n};\n```\n\nWe simply create a new stream dependent on the first stream. We declare\nthe stream as a dependency so that our stream wont return values before\nthe original stream produces its first value.\n\nFlyd includes a map function as part of its core.\n\n### Reducing a stream\n\nLets try something else, reducing a stream! It could look like this:\n\n```javascript\nvar reduceStream = function(s, f, acc) {\n  return stream([s], function() {\n    return f(acc, s());\n  });\n};\n```\n\nOur reduce function takes a stream, a reducer function and in initial\nvalue. Every time the original stream emit a value we pass it to the\nreducer along with the accumulator.\n\n### Applying a function to multiple streams\n\n### Creating a flat map\n\n## API\n\n### flyd.stream\n\nCreates a new stream.\n\n__Arguments__\n  * \\[`dependencies`\\] (array) – The streams on which this stream should initially depend.\n  * `body` (function|\\*) – The function body of the stream or it initial value.\n  * \\[`staticDependencies`\\] – Disables automatic dependency resolution of the stream.\n\n__Returns__\n\nThe created stream.\n\n###flyd.map(s, fn)\n\nReturns a new stream consisting of every value from `s` passed through `fn.\n\n__Example__\n```javascript\nvar numbers = stream(0);\nvar squaredNumbers = flyd.map(numbers, function(n) { return n*n; });\n```\n\n###flyd.reduce(s, fn, acc)\n\nCreates a new stream with the results of calling the function on every incoming\nstream with and accumulator and the incoming value.\n\n__Example__\n```javascript\nvar clicks = stream();\nelement.addEventListener(clicks);\nvar nrOfClicks = flyd.reduce(clicks, function(sum) { return sum+1; }, 0);\n```\n\n###flyd.merge(stream1, stream2)\n\nCreates a new stream down which all values from both `stream1` and `stream2`\nwill be sent.\n\n__Example__\n```javascript\nvar btn1Clicks = stream();\nbutton1Elm.addEventListener(clicks);\nvar btn2Clicks = stream();\nbutton2Elm.addEventListener(clicks);\nvar allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n```\n\n### flyd.transduce(stream, transducer)\n\nCreates a new stream resulting from applying `transducer` to `stream`.\n\n__Example__\n```javascript\n```\n\n###stream()\n\nReturns the last value of the stream.\n\n__Example__\n```javascript\nvar names = stream('Turing');\nnames(); // 'Turing'\nnames('Bohr');\nnames(); // 'Bohr'\n```\n\n###stream(val)\n\nPushes a value down the stream.\n\n###stream.map(f)\n\nReturns a new stream identical to the original exept every\nvalue will be passed through `f`.\n\n###stream1.ap(stream2)\n\n`stream1` must be a stream of functions.\n\nReturns a new stream which is the result of applying the\nfunctions from `stream1` to the values in `stream2`.\n",
  "readmeFilename": "README.md",
  "gitHead": "9315ba744800fd0b388a8f9da3673ab463f59bd6",
  "_id": "flyd@0.0.3",
  "_shasum": "0aed2b0e71657b593d8791a6e81d994f297b1d37",
  "_from": "flyd@*"
}
